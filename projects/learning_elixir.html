<!DOCTYPE HTML>
<html lang="en">
<head>
	<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Projects</title>
    <link rel="stylesheet" href="/bootstrap.min.css"/>
    <link rel="stylesheet" href="/default.css"/>
    <link rel="icon" type="image/png" href="/siteicon.png">
</head>
<body>

<div class="container">
    <div class="row mt-3">
        <a href="/"><img  alt="" src="/siteicon.png" width="50"></a>
    </div>
    <div class="row">
        <div class="col-md-8 mx-auto">
            <h1 class="mt-5 mb-1">Learning Elixir, my thoughts and study notes</h1>
            <div class="mb-4 text-secondary border-bottom">How and why you should Learn Elixir</div>
            <div><style type="text/css">
td {
    padding:0 15px;
}

.force-word-wrap pre code {
  white-space : pre-wrap !important;
}
</style>
<p style="text-align:center;">
    <img src="/Official_Elixir_logo.png" width="500" class="center">
</p>
<h1>Learning Elixir: Why?</h1>
<p>Why am I learning Elixir?</p>
<p>The short answer is: I have to know some Elixir for my current job, but I actually ended up really liking it. Elixirs functional programming paradigm reminds me of my first programming language, R, which brings back nostalgic memories. Although I initially learned R without knowing what a functional language was, Elixir is helping me appreciate the beauty of functional programming and how to create abstractions with just functions, without the need for mutable objects, methods, or classes.</p>
<p>Elixir’s syntax is concise and elegant, and it comes with several impressive features, such as pattern matching, which is explained further in this blog. One of the main draws of Elixir for me is that it’s built on Erlang, making it incredibly robust and highly concurrent, which I find really appealing. Additionally, Elixir has good documentation that is very accessible just like R, and it comes built-in with the language. The fact that Elixir has built-in pipes (<code>|&gt;</code>) like Linux or R, is also something that any R enthusiast can appreciate.</p>
<h1>Learning Elixir: Where to start?</h1>
<p>The main resource for learning is the official <a href="https://elixir-lang.org/getting-started/introduction.html">Getting Started</a>.
You can find everything there.</p>
<p>I am currently reading 2 books:</p>
<ul>
<li><a href="https://www.amazon.com/Learn-Functional-Programming-Elixir-Foundations/dp/168050245X">Learn Functional Programming With Elixir</a></li>
<li><a href="https://www.manning.com/books/elixir-in-action-second-edition">Elixir in action</a></li>
</ul>
<p>And I like them both.</p>
<p>And here you can find an <a href="https://github.com/christopheradams/elixir_style_guide">Elixir style guide</a> so you can code in style.</p>
<h1>Learning Elixir: My notes</h1>
<p>When learning a new programming language, the first thing I like to learn is:</p>
<ul>
<li>What is the language about?</li>
<li>What are the most important data types?</li>
<li>What are the semantics of the language?</li>
</ul>
<p>When you know these things, you can effectively read the documentation and really get going.</p>
<p>I use these notes as a quick reference in case I forget something.
Its a good intermediate between the documentation and reading the official Elixir tutorial (which is good).</p>
<p>These notes are verbose enough so you have some context, but terse enough that you don’t have to scroll through too much text.</p>
<h1>Elixir: A dense summary</h1>
<p>Elixir is a functional language.</p>
<p>Elixir is dynamically typed.</p>
<p>All data types in elixir are immutable.
Copies are always returned because everything is immutable.
To reduce the copying overhead, Elixir creates copies in a smart way, so they seem like copies but under the hood they aren’t.</p>
<p>Functions do not have side effects. They return their output, and do nothing else!
Check out this <a href="https://www.youtube.com/watch?v=0if71HOyVjY&amp;t=1743s">video</a> why that is something you want.</p>
<p>The Documentation of Elixir is amazing.</p>
<pre><code class="language-elixir"><span class="hljs-comment"># Get documentation on function, modules, operators:</span>

h <span class="hljs-title class_">Enum</span>.each
h <span class="hljs-title class_">File</span>
h <span class="hljs-keyword">case</span>
</code></pre>
<p>All code can be run in an interactive shell: <code>iex</code></p>
<h1>Elixir: My notes</h1>
<p>Next are my notes where I summarize the very basics of Elixir.</p>
<p>My suggestion for following along: get the <a href="https://raw.githubusercontent.com/trbKnl/my-personal-blog/main/blogs/learning_elixir.md">raw markdown</a> of these notes.
And run the examples in <code>iex</code>.
The examples try to show things that took me by surprise whenever I first encountered them.</p>
<p>What I personally do is, I use my own [vim plugin](<a href="https://niekdeschipper.com/projects/nvim_python_repl.md">https://niekdeschipper.com/projects/nvim_python_repl.md</a>] in nvim to send code to <code>iex</code>)
Although I really like my own plugin, I am using it for Python, NodeJS, R for a long time already and have no problems with it.</p>
<p>But if you are a <code>(n)vim</code> user you should probably use something like <a href="https://github.com/hkupty/iron.nvim">iron nvim</a>, never tried it out, but probably does exactly the same thing as my plugin and much more.</p>
<h1>The = match operator</h1>
<p><code>=</code> is the match operator, it tries to bind the right-hand side to the left-hand side to make the statement true.
This is an very important feature of Elixir.</p>
<p>Examples:</p>
<pre><code class="language-elixir">list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
[a, b, c] = list

{_, {hour, _, _}} = <span class="hljs-symbol">:calendar</span>.local_time  <span class="hljs-comment"># ignore a match with _</span>
{_date, time} = <span class="hljs-symbol">:calendar</span>.local_time      <span class="hljs-comment"># ignore a a match with _&lt;var_name&gt;</span>

[head | tail] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]  <span class="hljs-comment"># head has first item, tail the rest of the the list in a list</span>

{<span class="hljs-symbol">:ok</span>, file} = <span class="hljs-title class_">File</span>.open(<span class="hljs-string">&quot;./myfile&quot;</span>)
</code></pre>
<p>Pattern matches can be chained:</p>
<pre><code class="language-elixir">a = (b = <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)

datetime = {_date, time} = <span class="hljs-symbol">:calendar</span>.local_time
datetime
time

<span class="hljs-comment"># This ensures x will be a map if the patternmatching succeeds</span>
x = %{} = y
</code></pre>
<p>You can pattern match in function based on arguments:</p>
<pre><code class="language-elixir"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">Mul</span></span> <span class="hljs-keyword">do</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mul</span></span>({<span class="hljs-symbol">:two</span>, a}) <span class="hljs-keyword">do</span>
    a * <span class="hljs-number">2</span>
  <span class="hljs-keyword">end</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mul</span></span>({<span class="hljs-symbol">:three</span>, a}) <span class="hljs-keyword">do</span>
    a * <span class="hljs-number">3</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-title class_">Mul</span>.mul({<span class="hljs-symbol">:two</span>, <span class="hljs-number">2</span>})
<span class="hljs-title class_">Mul</span>.mul({<span class="hljs-symbol">:three</span>, <span class="hljs-number">2</span>})
</code></pre>
<p>Ignoring a value with underscore:</p>
<pre><code class="language-elixir">[a, _b] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
[a, _] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
</code></pre>
<p>Variable can only be bounded once:</p>
<pre><code class="language-elixir">[a, a] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
[a, a] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]  <span class="hljs-comment"># does not work</span>
</code></pre>
<p>Keep value of a fixed with caret called pin operator:</p>
<pre><code class="language-elixir">a = <span class="hljs-number">1</span>
^a = <span class="hljs-number">2</span>
</code></pre>
<p>See this example</p>
<pre><code class="language-elixir">list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
list2 = [<span class="hljs-number">4</span> | list1]
</code></pre>
<h1>Types in Elixir</h1>
<p>The most important complex data types are: Map, Tuple, List.
The primitive types I skipped well as the <code>atom</code>.
Atoms are constants whose values are their own name.
They are easy to grasp, read more <a href="https://hexdocs.pm/elixir/1.12/Atom.html">here</a>.</p>
<h2>Map</h2>
<p>Map is a key value store (dict in Python).</p>
<pre><code class="language-elixir"><span class="hljs-comment"># Map declarations</span>
%{<span class="hljs-symbol">:a</span> =&gt; <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-symbol">:b</span> =&gt; <span class="hljs-string">&quot;b&quot;</span>}
%{<span class="hljs-symbol">a:</span> <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-symbol">b:</span> <span class="hljs-string">&quot;b&quot;</span>}

a = %{<span class="hljs-symbol">a:</span> <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-symbol">b:</span> <span class="hljs-string">&quot;b&quot;</span>}
a[<span class="hljs-symbol">:a</span>]
a.a

<span class="hljs-comment"># Check if map has key:</span>
%{ <span class="hljs-symbol">a:</span> _ } = %{ <span class="hljs-symbol">a:</span> <span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-symbol">b:</span> <span class="hljs-string">&quot;bbb&quot;</span> }
%{ <span class="hljs-symbol">c:</span> _ } = %{ <span class="hljs-symbol">a:</span> <span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-symbol">b:</span> <span class="hljs-string">&quot;bbb&quot;</span> }
<span class="hljs-title class_">Map</span>.has_key?(%{ <span class="hljs-symbol">a:</span> <span class="hljs-string">&quot;aaa&quot;</span>}, <span class="hljs-symbol">:a</span>)

<span class="hljs-comment"># Update the value of key in map</span>
my_map = %{ <span class="hljs-symbol">a:</span> <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-symbol">b:</span> <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-symbol">c:</span> <span class="hljs-string">&quot;c&quot;</span> } 
%{my_map | <span class="hljs-symbol">a:</span> <span class="hljs-string">&quot;aaa&quot;</span>}
</code></pre>
<h2>Tuple</h2>
<p>Tuple module has function to work with tuples</p>
<pre><code class="language-elixir">person = {<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">30</span>}
elem(person, <span class="hljs-number">0</span>)
put_elem(person, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;Frikandel&quot;</span>)

<span class="hljs-keyword">import</span> <span class="hljs-title class_">Tuple</span>
<span class="hljs-title class_">Tuple</span>.append(person, <span class="hljs-string">&quot;Alice&quot;</span>)
</code></pre>
<h2>List</h2>
<p>Lists are implemented as singly linked lists. Most operations are O(n).</p>
<pre><code class="language-elixir">person = [<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>]
length(person)

<span class="hljs-comment"># Enum is the go to module to work with enumerables</span>
<span class="hljs-title class_">Enum</span>.at(person, <span class="hljs-number">1</span>)
<span class="hljs-title class_">Enum</span>.fetch(person, <span class="hljs-number">1</span>)      <span class="hljs-comment"># Returns {:ok, &quot;Alice&quot;}</span>
<span class="hljs-title class_">Enum</span>.fetch(person, <span class="hljs-number">3</span>)      <span class="hljs-comment"># Returns :error</span>
<span class="hljs-title class_">Enum</span>.fetch!(person, <span class="hljs-number">5</span>)     <span class="hljs-comment"># Throws Enum.OutOfBoundsError</span>
[head | tail] = person     <span class="hljs-comment"># Used a lot in recursion</span>
</code></pre>
<pre><code class="language-elixir">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] ++ [<span class="hljs-number">4</span>]   <span class="hljs-comment"># concatenation</span>
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] -- [<span class="hljs-number">1</span>]   <span class="hljs-comment"># difference </span>
<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> list        <span class="hljs-comment"># element in list</span>
</code></pre>
<h2>Keyword Lists</h2>
<p>An example how you can use default arguments:</p>
<pre><code class="language-elixir"><span class="hljs-comment"># Keyword list</span>
[<span class="hljs-symbol">aap:</span> <span class="hljs-string">&quot;aap&quot;</span>, <span class="hljs-symbol">crocodile:</span> <span class="hljs-string">&quot;crocodile&quot;</span>]

<span class="hljs-comment"># A keyword list just a normal list</span>
[<span class="hljs-symbol">a:</span> <span class="hljs-number">1</span>, <span class="hljs-symbol">b:</span> <span class="hljs-number">2</span>] == [{<span class="hljs-symbol">:a</span>, <span class="hljs-number">1</span>}, {<span class="hljs-symbol">:b</span>, <span class="hljs-number">2</span>}]
</code></pre>
<p>If a keyword list appears as the last item in any context, you can leave the square brackets off.
This is useful for supplying arguments to a function.
This really tripped me up the first time I saw it.</p>
<pre><code class="language-elixir"><span class="hljs-comment"># Example of keyword list as the last item</span>
<span class="hljs-comment"># notice the lack of square brackets</span>
fun.(x, y, <span class="hljs-symbol">a:</span> <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-symbol">b:</span> <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-symbol">c:</span> <span class="hljs-string">&quot;c&quot;</span>)
</code></pre>
<h2>MapSet</h2>
<p>Is the set data structure:</p>
<pre><code class="language-elixir">x = <span class="hljs-title class_">MapSet</span>.new()
x = <span class="hljs-title class_">MapSet</span>.put(x, <span class="hljs-string">&quot;ASD&quot;</span>)
x = <span class="hljs-title class_">MapSet</span>.put(x, <span class="hljs-string">&quot;QWE&quot;</span>)
x = <span class="hljs-title class_">MapSet</span>.put(x, <span class="hljs-string">&quot;QWE&quot;</span>)
<span class="hljs-title class_">MapSet</span>.member?(x, <span class="hljs-string">&quot;QWE&quot;</span>)
</code></pre>
<h2>Struct</h2>
<p>Struct is a typed map. One module can only define a single struct:</p>
<pre><code class="language-elixir"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">MyStruct</span></span> <span class="hljs-keyword">do</span>
  <span class="hljs-comment"># Keyword list provides fields and their initial values</span>
  <span class="hljs-keyword">defstruct</span> <span class="hljs-symbol">a:</span> <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-symbol">b:</span> <span class="hljs-string">&quot;B&quot;</span>
<span class="hljs-keyword">end</span>

my_struct = %<span class="hljs-title class_">MyStruct</span>{}
my_struct = %<span class="hljs-title class_">MyStruct</span>{<span class="hljs-symbol">a:</span> <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-symbol">b:</span> <span class="hljs-string">&quot;b&quot;</span>}

<span class="hljs-comment"># Patternmatch a struct</span>
%<span class="hljs-title class_">MyStruct</span>{<span class="hljs-symbol">a:</span> a, <span class="hljs-symbol">b:</span> b} = my_struct

<span class="hljs-comment"># Struct can&#x27;t patternmatch a map</span>
%<span class="hljs-title class_">MyStruct</span>{<span class="hljs-symbol">a:</span> a, <span class="hljs-symbol">b:</span> b} = %{<span class="hljs-symbol">a:</span> <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-symbol">b:</span> <span class="hljs-string">&quot;b&quot;</span>}
%{<span class="hljs-symbol">a:</span> a, <span class="hljs-symbol">b:</span> b} =  %<span class="hljs-title class_">MyStruct</span>{<span class="hljs-symbol">a:</span> <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-symbol">b:</span> <span class="hljs-string">&quot;b&quot;</span>} 
</code></pre>
<h2>String</h2>
<pre><code class="language-elixir"><span class="hljs-string">&quot;abcdefg&quot;</span>

<span class="hljs-comment"># format strings, string interpolation</span>
x =  <span class="hljs-string">&quot;format strings, string interpolation&quot;</span>
<span class="hljs-string">&quot;text: <span class="hljs-subst">#{x}</span>&quot;</span>

<span class="hljs-comment"># &lt;&gt; is used for concatenating binaries, strings are binaries</span>
<span class="hljs-string">&quot;concatenate&quot;</span> &lt;&gt; <span class="hljs-string">&quot;strings&quot;</span>
</code></pre>
<h2>Charlist</h2>
<p>A list of characters:</p>
<pre><code class="language-elixir"><span class="hljs-string">&#x27;abcdefg&#x27;</span>
char_list = <span class="hljs-string">&#x27;abcdefg&#x27;</span>
is_list(char_list) == <span class="hljs-literal">true</span>
<span class="hljs-title class_">Enum</span>.each(char_list, <span class="hljs-keyword">fn</span> x -&gt; <span class="hljs-title class_">IO</span>.puts(x) <span class="hljs-keyword">end</span>)
</code></pre>
<h2>Sigils</h2>
<p>Sigils are custom functions that work on text.
They are useful, and a means to extend the language.</p>
<pre><code class="language-elixir"><span class="hljs-comment"># Create a list of words</span>
h <span class="hljs-string">~w{}</span>
<span class="hljs-string">~w(the cat sat on the mat)</span>   <span class="hljs-comment"># list with strings</span>
<span class="hljs-string">~w(the cat sat on the mat)</span>a  <span class="hljs-comment"># list with atoms</span>
<span class="hljs-string">~w(the cat sat on the mat)</span>c  <span class="hljs-comment"># list with charlists</span>

<span class="hljs-comment"># Create a regex</span>
h <span class="hljs-regex">~r{}</span>
my_regex = <span class="hljs-regex">~r/foo/</span>
<span class="hljs-title class_">Regex</span>.replace(my_regex, <span class="hljs-string">&quot;foobar&quot;</span>, <span class="hljs-string">&quot;chill&quot;</span>)
</code></pre>
<h1>Functions</h1>
<p>Functions are defined by their name and arity (the number of input arguments).</p>
<h2>Anonymous functions</h2>
<p>Anonymous function can be assigned to a variable.
Function can return functions, and can be used as arguments.
Functions are defined by their name and arity (the number of arguments a function has)</p>
<p>Example:</p>
<pre><code class="language-elixir">list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
sum = <span class="hljs-keyword">fn</span> list -&gt; <span class="hljs-title class_">Enum</span>.sum(list) <span class="hljs-keyword">end</span>
sum.(list)
</code></pre>
<p>Single function can have multiple bodies.
I was blown away when I saw this at first.
The function body that matches the input argument is returned.
Conditional logic without if else statements!</p>
<pre><code class="language-elixir">fizz = <span class="hljs-keyword">fn</span> 
  (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, _) -&gt; <span class="hljs-string">&quot;FizzBuzz&quot;</span>
  (<span class="hljs-number">0</span>, _, _) -&gt; <span class="hljs-string">&quot;Fizz&quot;</span>
  (_, <span class="hljs-number">0</span>, _) -&gt; <span class="hljs-string">&quot;Buzz&quot;</span>
  (_, _, c) -&gt; c
<span class="hljs-keyword">end</span>

<span class="hljs-title class_">IO</span>.puts(fizz.(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>))
<span class="hljs-title class_">IO</span>.puts(fizz.(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))
<span class="hljs-title class_">IO</span>.puts(fizz.(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))
<span class="hljs-title class_">IO</span>.puts(fizz.(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>))
</code></pre>
<p>Anonymous functions have a shorthand:</p>
<pre><code class="language-elixir"><span class="hljs-comment"># Shorthand</span>
fun1 = <span class="hljs-keyword">fn</span> x -&gt; x + <span class="hljs-number">1</span> <span class="hljs-keyword">end</span> 
fun2 = &amp;(&amp;<span class="hljs-number">1</span> + <span class="hljs-number">1</span>)

fun1.(<span class="hljs-number">1</span>) == fun2.(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 1 == 1</span>

<span class="hljs-comment"># You can capture functions</span>
x = &amp;<span class="hljs-title class_">IO</span>.puts/<span class="hljs-number">1</span>
x.(<span class="hljs-string">&quot;string&quot;</span>)
</code></pre>
<h2>Named functions</h2>
<p>Named functions have to be in modules:</p>
<pre><code class="language-elixir"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">Times</span></span> <span class="hljs-keyword">do</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">double</span></span>(n) <span class="hljs-keyword">do</span>
    n * <span class="hljs-number">2</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">Times</span></span> <span class="hljs-keyword">do</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">double</span></span>(n), <span class="hljs-symbol">do:</span> n * <span class="hljs-number">2</span>
<span class="hljs-keyword">end</span>

<span class="hljs-title class_">Times</span>.double(<span class="hljs-number">2</span>)
</code></pre>
<p>Functions can be pattern matched, it will try to match based on the function definition order.
This is a means to create conditional logic in your code, without if else statements.
Define from most specific to general</p>
<pre><code class="language-elixir"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">Add</span></span> <span class="hljs-keyword">do</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(n) <span class="hljs-keyword">when</span> is_integer(n), <span class="hljs-symbol">do:</span> n + n

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>([x, y]), <span class="hljs-symbol">do:</span> x + y

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>({a, b}), <span class="hljs-symbol">do:</span> a + b
<span class="hljs-keyword">end</span>

<span class="hljs-title class_">Add</span>.add(<span class="hljs-number">2</span>)
<span class="hljs-title class_">Add</span>.add([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
<span class="hljs-title class_">Add</span>.add({<span class="hljs-number">2</span>, <span class="hljs-number">3</span>})
<span class="hljs-title class_">Add</span>.add([])     <span class="hljs-comment"># error, no match found</span>
</code></pre>
<p>You can clause guard with “when” first patternmatch then guard clauses.
Check where guards can be used, its in quite a lot of places.</p>
<pre><code class="language-elixir"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">Guard</span></span> <span class="hljs-keyword">do</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">what_is</span></span>(x) <span class="hljs-keyword">when</span> is_number(x) <span class="hljs-keyword">do</span>
    <span class="hljs-title class_">IO</span>.puts <span class="hljs-string">&quot;<span class="hljs-subst">#{x}</span> is a number&quot;</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">what_is</span></span>(x) <span class="hljs-keyword">when</span> is_list(x) <span class="hljs-keyword">do</span>
    <span class="hljs-title class_">IO</span>.puts <span class="hljs-string">&quot;<span class="hljs-subst">#{inspect(x)}</span> is a list&quot;</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">what_is</span></span>(x) <span class="hljs-keyword">when</span> is_atom(x) <span class="hljs-keyword">do</span>
    <span class="hljs-title class_">IO</span>.puts <span class="hljs-string">&quot;<span class="hljs-subst">#{x}</span> is an atom&quot;</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-title class_">Guard</span>.what_is(<span class="hljs-number">99</span>)
<span class="hljs-title class_">Guard</span>.what_is(<span class="hljs-symbol">:cat</span>)
<span class="hljs-title class_">Guard</span>.what_is([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])
</code></pre>
<p>Functions with an !, will raise an exception if the function encounters an error:</p>
<pre><code>h File.stream!
</code></pre>
<p><code>defp</code> defines a private function which can only be used in the module.</p>
<h1>Conditional logic</h1>
<p>The most important conditional logic in Elixir: <code>case</code>, <code>cond</code> and pattern matching on function arguments.</p>
<h2>case: matches values</h2>
<p>The <code>case</code> statement matches values!</p>
<pre><code class="language-elixir">result1 = {<span class="hljs-symbol">:ok</span>, <span class="hljs-string">&quot;lets, go!&quot;</span>}
result2 = {<span class="hljs-symbol">:error</span>, <span class="hljs-string">&quot;lets, go!&quot;</span>}

case_example = <span class="hljs-keyword">fn</span> pattern -&gt;
  <span class="hljs-keyword">case</span> pattern <span class="hljs-keyword">do</span>
    {<span class="hljs-symbol">:ok</span>, str} -&gt; <span class="hljs-title class_">IO</span>.puts(str)
      {<span class="hljs-symbol">:success</span>, <span class="hljs-string">&quot;we can continue&quot;</span>}
    _ -&gt; <span class="hljs-title class_">IO</span>.puts(<span class="hljs-string">&quot;whomp, whomp&quot;</span>)  <span class="hljs-comment"># _ matches anything</span>
      {<span class="hljs-symbol">:faillure</span>, <span class="hljs-string">&quot;:(&quot;</span>}
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

case_example.(result1)
case_example.(result2)
</code></pre>
<h2>cond: matches conditions</h2>
<p><code>cond</code> matches conditions:</p>
<pre><code class="language-elixir">x = <span class="hljs-number">1</span>
<span class="hljs-keyword">cond</span> <span class="hljs-keyword">do</span> 
  x == <span class="hljs-number">1</span> -&gt; <span class="hljs-string">&quot;I am true&quot;</span>
  x != <span class="hljs-number">1</span> -&gt; <span class="hljs-string">&quot;I am false&quot;</span>
  <span class="hljs-literal">true</span> -&gt; <span class="hljs-symbol">:error</span>  <span class="hljs-comment"># a catch all, because it always matches</span>
<span class="hljs-keyword">end</span>

</code></pre>
<h2>with: traverse a matching chain</h2>
<p><code>with</code> keeps evaluating, and enters the do block if all patterns match
If not match return that pattern: for example {:error, “reason why failed”}</p>
<pre><code class="language-elixir"><span class="hljs-keyword">with</span> {<span class="hljs-symbol">:ok</span>, name} &lt;- {<span class="hljs-symbol">:ok</span>, <span class="hljs-string">&quot;banaan&quot;</span>},
     {<span class="hljs-symbol">:ok</span>, login_id} &lt;- {<span class="hljs-symbol">:ok</span>, <span class="hljs-string">&quot;banaan&quot;</span>} <span class="hljs-keyword">do</span>
  %{<span class="hljs-symbol">name:</span> name, <span class="hljs-symbol">login_id:</span> login_id}
<span class="hljs-keyword">end</span>
</code></pre>
<h2>if else/unless</h2>
<p>You have if and its inverse unless. For more than one else statement use <code>cond</code>.</p>
<pre><code class="language-elixir">compare_int = <span class="hljs-keyword">fn</span> x -&gt;
  <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">do</span>
    <span class="hljs-symbol">:greater_than_or_equal_to_one</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-symbol">:less_than_one</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

compare_int.(<span class="hljs-number">0</span>)
</code></pre>
<h1>Processing collections</h1>
<h2>Enum: eager</h2>
<p>Enum is the go to library to process collections.
Enum is eager.</p>
<pre><code class="language-elixir">h <span class="hljs-title class_">Enum</span>
list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-title class_">Enum</span>.filter(list, &amp;(&amp;<span class="hljs-number">1</span> != <span class="hljs-number">2</span>))

<span class="hljs-comment"># Maps are also enumerables</span>
<span class="hljs-comment"># This example shows how maps are treated by enum</span>
<span class="hljs-comment"># Similar to [(k, v) for k, v in my_dictionary.items()] in Python</span>
<span class="hljs-title class_">Enum</span>.each(%{<span class="hljs-symbol">a:</span> <span class="hljs-number">1</span>, <span class="hljs-symbol">b:</span> <span class="hljs-number">2</span>}, <span class="hljs-keyword">fn</span> {key, value} -&gt; <span class="hljs-title class_">IO</span>.puts(<span class="hljs-string">&quot;key <span class="hljs-subst">#{key}</span>, value <span class="hljs-subst">#{value}</span>&quot;</span>) <span class="hljs-keyword">end</span>)

<span class="hljs-comment"># Also works for keyword lists</span>
<span class="hljs-title class_">Enum</span>.each([<span class="hljs-symbol">a:</span> <span class="hljs-number">1</span>, <span class="hljs-symbol">b:</span> <span class="hljs-number">2</span>], <span class="hljs-keyword">fn</span> {key, value} -&gt; <span class="hljs-title class_">IO</span>.puts(<span class="hljs-string">&quot;key <span class="hljs-subst">#{key}</span>, value <span class="hljs-subst">#{value}</span>&quot;</span>) <span class="hljs-keyword">end</span>)
</code></pre>
<h2>Stream: lazy</h2>
<p>Streams are lazy, they only deliver the next item in line when requested.</p>
<pre><code class="language-elixir">my_stream = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>]

my_stream 
  |&gt; <span class="hljs-title class_">Stream</span>.map(<span class="hljs-keyword">fn</span> x -&gt; x &lt;&gt; x <span class="hljs-keyword">end</span>)  <span class="hljs-comment"># &lt;&gt; concatenates binaries ( asequence of bits divisible by 8): strings are binaries</span>
  |&gt; <span class="hljs-title class_">Enum</span>.take(<span class="hljs-number">1</span>)

<span class="hljs-title class_">Stream</span>.unfold(<span class="hljs-number">0</span>, <span class="hljs-keyword">fn</span>   <span class="hljs-comment"># check: h Stream.unfold</span>
  x -&gt; {x,  x + <span class="hljs-number">1</span>}
<span class="hljs-keyword">end</span>) 
  |&gt; <span class="hljs-title class_">Stream</span>.map(<span class="hljs-keyword">fn</span> x -&gt; x + x <span class="hljs-keyword">end</span>)
  |&gt; <span class="hljs-title class_">Enum</span>.take(<span class="hljs-number">20</span>)
</code></pre>
<h2>List comprehension</h2>
<p>List comprehension exists!</p>
<p>It evaluates all combinations of multiple input sequences.
If conditions is <code>true</code> do something and return the result.</p>
<pre><code class="language-elixir"><span class="hljs-keyword">for</span> a &lt;- <span class="hljs-number">1</span>..<span class="hljs-number">10</span>, a  &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> a &lt;= <span class="hljs-number">4</span>, <span class="hljs-symbol">do:</span> a
<span class="hljs-keyword">for</span> a <span class="hljs-keyword">when</span> a &lt; <span class="hljs-number">5</span> &lt;- <span class="hljs-number">1</span>..<span class="hljs-number">10</span>, <span class="hljs-symbol">do:</span> a

<span class="hljs-comment"># Creative zip using list comprehension</span>
my_zip =  <span class="hljs-keyword">fn</span>(list1, list2) -&gt;
  <span class="hljs-keyword">for</span> {x_value, x_index} &lt;- <span class="hljs-title class_">Enum</span>.with_index(list1),
    {y_value, y_index} &lt;- <span class="hljs-title class_">Enum</span>.with_index(list2),
    x_index == y_index,
    <span class="hljs-symbol">into:</span> [] <span class="hljs-keyword">do</span>
  {x_value, y_value}
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

my_zip.([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>])
</code></pre>
</div>
        </div>
    </div>
</div>


</body>
</html>


