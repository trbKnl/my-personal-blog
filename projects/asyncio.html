<!DOCTYPE HTML>
<html lang="en">
<head>
	<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Projects</title>
    <link rel="stylesheet" href="/bootstrap.min.css"/>
    <link rel="stylesheet" href="/default.css"/>
    <link rel="icon" type="image/png" href="/siteicon.png">
</head>
<body>

<div class="container">
    <div class="row mt-3">
        <a href="/"><img  alt="" src="/siteicon.png" width="50"></a>
    </div>
    <div class="row">
        <div class="col-md-8 mx-auto">
            <h1 class="mt-5 mb-1">Concurrent programming in Python with Asynchronous I/O</h1>
            <div class="mb-4 text-secondary border-bottom">An introduction to asyncio with an example</div>
            <div><style type="text/css">
td {
    padding:0 15px;
}
</style>
<h3 class="border-bottom mb-3 mt-5" id="goal-of-this-blog-post">Goal of this blog post</h3>
<p>In this blog post I will talk about the <code>asyncio</code> library in Python. This is a Python library that lets you write concurrent code using the <code>async/await</code> syntax.
Without <code>asyncio</code>, when you run a (single threaded) program and an input output (I/O) action happens (a database read, waiting for user input, etc.) your program will wait for the I/O action to complete and then it will continue doing its thing. In the mean time, while this I/O action is happening, your program is doing nothing. Wouldn’t it be cool if your program could do something else, while waiting for this I/O action to complete? That is what <code>asyncio</code> is all about.</p>
<p>In this blog post you will learn:</p>
<ul>
<li>The <code>async/await</code> syntax introduced by the <code>asyncio</code> package</li>
<li>How to use websockets, we will use this to send data (asynchronously) back and forth between client and server</li>
</ul>
<p>I will start by briefly discussing the topic and the syntax involved and then we will dive into an example, because an example say more than a thousand words.
This blog post adds something to the other explanation on the web because it includes a non-trivial and hopefully an interesting example of an asynchronous program.</p>
<h2 class="border-bottom mb-3 mt-5" id="Introduction">An introduction to async/await syntax</h2>
<p><code>Asyncio</code> lets you write concurrent code, with concurrent code you can make your programs do other things while an I/O operation is happening. An example of where this is useful is a webserver. The webserver could serve one person, while waiting for input from another person.</p>
<p><code>Asyncio</code> works with coroutines and awaitables. A coroutine is a function with awaitables in it. Here is an example:</p>
<pre><code class="language-pyton">import asyncio

# This is a coroutine, which is indicated by the async keyword
async def hello():
    print(&quot;hello&quot;)

    # This is an awaitable during an awaitable other coroutines are allowed to run
    await asyncio.sleep(5)
    print(&quot;bye&quot;)

# To run the coroutine use asyncio.run()
asyncio.run(hello())
</code></pre>
<p>An awaitable is a piece of code that can be awaited on, an awaitable is special, meaning, when something is awaited, other coroutines are allowed to run. So in this example, while the <code>hello()</code> function is sleeping for 5 seconds. Other coroutines could be doing something else in the meantime: such as database reads, calculations, checking if users supplied input and so on. When the 5 second sleep is up, the coroutine <code>hello()</code> will be resumed, and <code>&quot;bye&quot;</code> will be printed to the console.</p>
<p>Coroutines are functions defined with the <code>async</code> keyword (see the definition of <code>hello()</code>). A coroutine must have an awaitable in it.</p>
<p>Awaitables are indicated using the <code>await</code> keyword. Note: In this example <code>await asyncio.sleep(5)</code> is not returning anything. But it is possible to await a coroutine that does return data, we will see that in an upcoming example.</p>
<p>In order to execute a coroutine you can use the <code>asyncio.run()</code> function. This function will add your coroutine to the event loop. The event loop is what makes that this whole thing work. The event loop works like this:</p>
<ol>
<li>Beginning of the event loop</li>
<li>Execute code</li>
<li>If something needs to be awaited, check if other coroutines can be executed</li>
<li>Execute code</li>
<li>Check if awaitables have returned, if yes, resume code execution from there</li>
<li>Execute code</li>
<li>Go back to 1 until there is no more code left to execute</li>
</ol>
<p>Because you add coroutines in an event loop, that keeps polling if coroutines are finished, while in the mean time running other code. Your program can run very efficiently, creating the illusion that everything happens at the same time.</p>
<h2 class="border-bottom mb-3 mt-5" id="Introduction">A simple example</h2>
<p>The next example perfectly illustrates how asynchronous code could be useful.
In this example I created a <em>blocking</em> version of <code>hello()</code> and a <em>non-blocking</em> version of <code>hello()</code>.</p>
<p>Try the code yourself.</p>
<p>Can you predict what will be printed to the console, and how long each function will take?</p>
<pre><code class="language-python"><span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">import</span> time

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_nonblocking</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>)
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">5</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;bye&quot;</span>)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_blocking</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>)
    time.sleep(<span class="hljs-number">5</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;bye&quot;</span>)


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main_nonblocking</span>():
    <span class="hljs-comment"># gather() lets coroutines run at the same time</span>
    <span class="hljs-comment"># and await all its results</span>
    <span class="hljs-keyword">await</span> asyncio.gather(
        hello_nonblocking(),
        hello_nonblocking(),
        hello_nonblocking()
    )

<span class="hljs-keyword">def</span> <span class="hljs-title function_">main_blocking</span>():
    hello_blocking()
    hello_blocking()
    hello_blocking()


t = time.time()
main_blocking()
elapsed_time = time.time() - t
<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The blocking version took: <span class="hljs-subst">{elapsed_time}</span> seconds&quot;</span>)

t = time.time()
asyncio.run(main_nonblocking())
elapsed_time = time.time() - t
<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The non-blocking version took: <span class="hljs-subst">{elapsed_time}</span> seconds&quot;</span>)
</code></pre>
<h3 id="building-a-working-script">An example with websockets</h3>
<p>The previous example pinpoints the important concepts. But it is not very interesting because it only uses <code>sleep()</code>.  When I encountered these examples I thought,
oke cool, I get it… I think, but now my program can sleep concurrently? That seems pointless.</p>
<p>That is why I will discuss an example here that is less trivial. This example will demonstrate clearly why concurrent code is awesome.
The example will make use of websockets (A websocket is a lot like a normal <a href="https://en.wikipedia.org/wiki/Network_socket">socket</a>, but if you don’t know those, forget about it). You can read from and write data to a socket, just like you would from a file, but then it works over a network (such as your home network or the internet). If you write bytes, strings, whatever to a websocket, somebody on the other end of the network could read from it and receive your data.</p>
<p>A websocket can be used to send real time data back and forth, for example, to update the leader board for a game.</p>
<p>A websocket works as follows:</p>
<ol>
<li>A server creates the websocket using a port number</li>
<li>Clients can connect to the websocket using the specified port number and the IP address of the server</li>
<li>Data can now be send and received from server to client with <code>websocket.send()</code> and <code>websocket.recv()</code></li>
</ol>
<p>Websockets are ideal for this example because reading from, and writing to websockets is awaitable. Meaning, that when the server is waiting to receive data from a client, in the meantime it can do other things. So if a client is slow, and has not send any data yet, the server is not blocked and can server other people.</p>
<p>In this example I am going to create a client program and a server program. First we will discuss the client program, and then the server program</p>
<p>This is the code for the client program:</p>
<pre><code class="language-python"><span class="hljs-comment">#!/usr/bin/env python</span>

<span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">import</span> websockets
<span class="hljs-keyword">import</span> random

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">client_program</span>():
    uri = <span class="hljs-string">&quot;ws://localhost:8765&quot;</span>

    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> websockets.connect(uri) <span class="hljs-keyword">as</span> websocket:
        greeting = <span class="hljs-keyword">await</span> websocket.recv()
        <span class="hljs-built_in">print</span>(greeting)

        name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;What is your name? &quot;</span>)
        <span class="hljs-keyword">await</span> websocket.send(name)

        actions = [<span class="hljs-string">&quot;crunching numbers&quot;</span>, <span class="hljs-string">&quot;database inserts&quot;</span>, 
                   <span class="hljs-string">&quot;vlookups in excel&quot;</span>, <span class="hljs-string">&quot;deleting stuff&quot;</span>, 
                   <span class="hljs-string">&quot;formatting disk&quot;</span>, <span class="hljs-string">&quot;looking for aliens&quot;</span>, 
                   <span class="hljs-string">&quot;buying and selling bitcoin&quot;</span>, <span class="hljs-string">&quot;disconnect&quot;</span>]

        probability_of_occurring = [<span class="hljs-number">0.3</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>]

        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
                <span class="hljs-comment"># pick a new action and take up to 3 seconds to carefully think about it</span>
                <span class="hljs-keyword">await</span> asyncio.sleep(random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>))
                action = random.choices(actions, probability_of_occurring)[<span class="hljs-number">0</span>]

                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(client) The server is going to preform: <span class="hljs-subst">{action}</span>&quot;</span>)
                <span class="hljs-keyword">await</span> websocket.send(action)

                response = <span class="hljs-keyword">await</span> websocket.recv()
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(client) Response from server: <span class="hljs-subst">{response}</span>&quot;</span>)
        <span class="hljs-keyword">except</span> websockets.exceptions.ConnectionClosedOK:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(client) Disconnected from server&quot;</span>)

asyncio.run(client_program())
</code></pre>
<p>The client program works as follows:</p>
<ol>
<li>It connects to the servers websocket using the uri</li>
<li>The client will wait for a message from the server and print it to the console</li>
<li>You are asked to type in your name</li>
<li>Your name is send to the server</li>
<li>1 of 8 actions is picked at random, one of them is disconnect</li>
<li>This action is send to the server</li>
<li>The client will wait for a response from the server and print it to the console</li>
<li>Go back to step 5 until the server disconnects</li>
</ol>
<p>In short: you send a random made up action to the server, wait for its response and print it to the screen, until disconnect.</p>
<p>Onto the server program program. The server program consists of three functions:</p>
<ul>
<li><code>costly_io_operation()</code> which simulates a costly operation that can be done asynchronous such as reading from a database, or doing some calculation elsewhere.</li>
<li><code>server()</code> which is the webserver</li>
<li><code>main()</code> which is the main program that makes it work</li>
</ul>
<p>The code is as follows:</p>
<pre><code class="language-python"><span class="hljs-comment">#!/usr/bin/env python</span>

<span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">import</span> websockets

HOST = <span class="hljs-string">&quot;127.0.01&quot;</span>
PORT = <span class="hljs-number">8765</span>

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">costly_io_operation</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span>, action: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-comment"># Determine the &quot;processing time&quot; by drawing a random integer</span>
    processing_time = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(server) Performing <span class="hljs-subst">{action}</span> for client: <span class="hljs-subst">{name}</span>&quot;</span>)

    <span class="hljs-comment"># Simulate a costly IO operation by sleeping, allowing other coroutines to run</span>
    <span class="hljs-keyword">await</span> asyncio.sleep(processing_time)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(server) Preformed <span class="hljs-subst">{action}</span> for client: <span class="hljs-subst">{name}</span> in <span class="hljs-subst">{processing_time}</span> seconds&quot;</span>)

    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">{action}</span> was successful&quot;</span>


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">server</span>(<span class="hljs-params">websocket, path</span>):
    <span class="hljs-keyword">await</span> websocket.send(<span class="hljs-string">&quot;Connected to server&quot;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;(server) Client connected to server &quot;</span>)

    <span class="hljs-comment"># Receive the clients name</span>
    client_name = <span class="hljs-keyword">await</span> websocket.recv()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(server) Clients name is: <span class="hljs-subst">{client_name}</span>&quot;</span>)

    <span class="hljs-comment"># Wait on the first action to perform</span>
    action = <span class="hljs-keyword">await</span> websocket.recv()

    <span class="hljs-keyword">while</span> action != <span class="hljs-string">&quot;disconnect&quot;</span>:
        response = <span class="hljs-keyword">await</span> costly_io_operation(client_name, action)
        <span class="hljs-keyword">await</span> websocket.send(response)

        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(server) Awaiting new action from client: <span class="hljs-subst">{client_name}</span>&quot;</span>)
        action = <span class="hljs-keyword">await</span> websocket.recv()

    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(server) client: <span class="hljs-subst">{client_name}</span> wants to stop, closing connection&quot;</span>)
    <span class="hljs-keyword">await</span> websocket.close()


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;(server) Starting server, waiting for clients to connect...&quot;</span>)
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> websockets.serve(server, HOST, PORT):
        <span class="hljs-keyword">await</span> asyncio.Future()  <span class="hljs-comment"># run forever</span>


asyncio.run(main())
</code></pre>
<p>The server program works as follows:</p>
<ol>
<li>It waits for a client to connect and sends a message</li>
<li>It waits for the client to sends its name, and prints it to the console</li>
<li>It awaits an action from the client</li>
<li>It performs the action</li>
<li>And sends the result from the action back to the client</li>
<li>Back to 3, until the action is to disconnect</li>
</ol>
<p>In short: <code>main()</code> listens for connections and hands them off to <code>server()</code>, which does costly IO operations with <code>costly_io_operation()</code>.</p>
<p>To run these scripts, save the as <code>client.py</code> and <code>server.py</code> and make them executable with <code>chmod +x ./client.py ./server.py</code>. Which means, change the mode of these files to make them executable. You need to have the libraries installed.</p>
<p>First start the server with,</p>
<pre><code class="language-bash">$ ./server.py
</code></pre>
<p>Then fire up multiple clients, in separate terminals with,</p>
<pre><code class="language-bash">$ ./cient.py
</code></pre>
<p>And watch the server go to work! Because the server uses asynchronous code, it can handle multiple clients at once, while the server is waiting for the results of one client, it can accept actions from other clients.</p>
<p>Really fun is to push this server to its limits and experience asyncio to its fullest potential.
You can do that by firing up a server in a terminal, and let <strong>a lot of clients connect at the same time</strong>.</p>
<p>You can connect multiple clients to the server using:</p>
<pre><code class="language-bash">$ <span class="hljs-keyword">for</span> client <span class="hljs-keyword">in</span> client{1..10}; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$client</span> | ./client.py &amp;; <span class="hljs-keyword">done</span>
</code></pre>
<p>This line means; generate 10 strings, “client1”, “client2” … “client10”, for each of these strings, send them to input of the client program (with the pipe operator <code>|</code>), this will simulate you typing in the name of the client and then it frees up the terminal by sending the program to the background with <code>&amp;</code>. This is needed so another client can be fired up in the same terminal.</p>
<p>How many clients can your server handle?</p>
<p>Ten?</p>
<pre><code class="language-bash">$ <span class="hljs-keyword">for</span> client <span class="hljs-keyword">in</span> client{1..10}; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$client</span> | ./client.py &amp;; <span class="hljs-keyword">done</span>
</code></pre>
<p>A hundered?</p>
<pre><code class="language-bash">$ <span class="hljs-keyword">for</span> client <span class="hljs-keyword">in</span> client{1..100}; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$client</span> | ./client.py &amp;; <span class="hljs-keyword">done</span>
</code></pre>
<p>Thousand?</p>
<pre><code class="language-bash">$ <span class="hljs-keyword">for</span> client <span class="hljs-keyword">in</span> client{1..1000}; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$client</span> | ./client.py &amp;; <span class="hljs-keyword">done</span>
</code></pre>
<p>Tip: If want to stop running all the clients just <code>Control + C</code> the server program and all the clients will crash.</p>
<h3 id="building-a-working-script">Not just any function can become a coroutine</h3>
<p>If you want to use asyncio you need to use packages that are compatible with asyncio.</p>
<p>If you want to use a redis database with Python, you can use the Python package <code>redis</code>. The functions from the <code>redis</code> package cannot be awaited and therefore they will be blocking! But you can also use the <code>aioredis</code> package which adds asynchronous support. So you can read and write to a redis data base asynchronously.</p>
<p>Conclusion: You need Python libraries with asynchronous support! Luckily, there are a lot of them, such as <code>websockets</code> and <code>aioredis</code> and many more.</p>
<h3 id="building-a-working-script">The full code</h3>
<p>The client program:</p>
<pre><code class="language-python"><span class="hljs-comment">#!/usr/bin/env python</span>

<span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">import</span> websockets
<span class="hljs-keyword">import</span> random

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">client_program</span>():
    uri = <span class="hljs-string">&quot;ws://localhost:8765&quot;</span>

    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> websockets.connect(uri) <span class="hljs-keyword">as</span> websocket:
        greeting = <span class="hljs-keyword">await</span> websocket.recv()
        <span class="hljs-built_in">print</span>(greeting)

        name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;What is your name? &quot;</span>)
        <span class="hljs-keyword">await</span> websocket.send(name)

        actions = [<span class="hljs-string">&quot;crunching numbers&quot;</span>, <span class="hljs-string">&quot;database inserts&quot;</span>, 
                   <span class="hljs-string">&quot;vlookups in excel&quot;</span>, <span class="hljs-string">&quot;deleting stuff&quot;</span>, 
                   <span class="hljs-string">&quot;formatting disk&quot;</span>, <span class="hljs-string">&quot;looking for aliens&quot;</span>, 
                   <span class="hljs-string">&quot;buying and selling bitcoin&quot;</span>, <span class="hljs-string">&quot;disconnect&quot;</span>]

        probability_of_occurring = [<span class="hljs-number">0.3</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>]

        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
                <span class="hljs-comment"># pick a new action and take up to 3 seconds to carefully think about it</span>
                <span class="hljs-keyword">await</span> asyncio.sleep(random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>))
                action = random.choices(actions, probability_of_occurring)[<span class="hljs-number">0</span>]

                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(client) The server is going to preform: <span class="hljs-subst">{action}</span>&quot;</span>)
                <span class="hljs-keyword">await</span> websocket.send(action)

                response = <span class="hljs-keyword">await</span> websocket.recv()
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(client) Response from server: <span class="hljs-subst">{response}</span>&quot;</span>)
        <span class="hljs-keyword">except</span> websockets.exceptions.ConnectionClosedOK:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(client) Disconnected from server&quot;</span>)

asyncio.run(client_program())
</code></pre>
<p>The server program:</p>
<pre><code class="language-python"><span class="hljs-comment">#!/usr/bin/env python</span>

<span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">import</span> websockets

HOST = <span class="hljs-string">&quot;127.0.01&quot;</span>
PORT = <span class="hljs-number">8765</span>

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">costly_io_operation</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span>, action: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-comment"># Determine the processing time by drawing a random integer</span>
    processing_time = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(server) Performing <span class="hljs-subst">{action}</span> for client: <span class="hljs-subst">{name}</span>&quot;</span>)

    <span class="hljs-comment"># Simulate a costly IO operation by sleeping, allowing other coroutines to run</span>
    <span class="hljs-keyword">await</span> asyncio.sleep(processing_time)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(server) Preformed <span class="hljs-subst">{action}</span> for client: <span class="hljs-subst">{name}</span> in <span class="hljs-subst">{processing_time}</span> seconds&quot;</span>)

    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">{action}</span> was successful&quot;</span>


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">server</span>(<span class="hljs-params">websocket, path</span>):
    <span class="hljs-keyword">await</span> websocket.send(<span class="hljs-string">&quot;Connected to server&quot;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;(server) Client connected to server &quot;</span>)

    <span class="hljs-comment"># Receive the clients name</span>
    client_name = <span class="hljs-keyword">await</span> websocket.recv()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(server) Clients name is: <span class="hljs-subst">{client_name}</span>&quot;</span>)

    <span class="hljs-comment"># Wait on the first action to perform</span>
    action = <span class="hljs-keyword">await</span> websocket.recv()

    <span class="hljs-keyword">while</span> action != <span class="hljs-string">&quot;disconnect&quot;</span>:
        response = <span class="hljs-keyword">await</span> costly_io_operation(client_name, action)
        <span class="hljs-keyword">await</span> websocket.send(response)

        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(server) Awaiting new action from client: <span class="hljs-subst">{client_name}</span>&quot;</span>)
        action = <span class="hljs-keyword">await</span> websocket.recv()

    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(server) client: <span class="hljs-subst">{client_name}</span> wants to stop, closing connection&quot;</span>)
    <span class="hljs-keyword">await</span> websocket.close()


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;(server) Starting server, waiting for clients to connect...&quot;</span>)
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> websockets.serve(server, HOST, PORT):
        <span class="hljs-keyword">await</span> asyncio.Future()  <span class="hljs-comment"># run forever</span>


asyncio.run(main())
</code></pre>
</div>
        </div>
    </div>
</div>


</body>
</html>


